package com.schottenTotten.controller;

import com.schottenTotten.model.Borne;
import com.schottenTotten.model.Carte;
import com.schottenTotten.model.Couleur;
import com.schottenTotten.model.Joueur;
import com.schottenTotten.view.VueConsole;
import com.schottenTotten.ai.StrategieIA;
import com.schottenTotten.ai.IAAleatoire;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;    
import java.util.List;

public class ControleurJeu {
    private List<Borne> bornes;
    private List<Carte> pioche;
    private Joueur j1;
    private Joueur j2;
    private VueConsole vue;
    private StrategieIA strategieIA;

    public ControleurJeu() {
        this.vue = new VueConsole();
        this.bornes = new ArrayList<>();
        // Création des 9 bornes
        for (int i = 0; i < 9; i++) {
            bornes.add(new Borne(i));
        }
        this.pioche = creerPioche();
        this.strategieIA = new IAAleatoire(); 
    }

    // Crée et mélange le paquet de 54 cartes (6 couleurs et 9 valeurs).
    
    private List<Carte> creerPioche() {
        List<Carte> nouvellePioche = new ArrayList<>();
        for (Couleur c : Couleur.values()) {
            for (int i = 1; i <= 9; i++) {
                nouvellePioche.add(new Carte(c, i));
            }
        }
        Collections.shuffle(nouvellePioche);
        return nouvellePioche;
    }

    // Méthode principale qui lance la boucle de jeu.

    public void lancerPartie() {
        vue.afficherMessage("Bienvenue dans Schotten-Totten !");

        j1 = new Joueur("Joueur 1 (Humain)", false);
        
        int mode = vue.demanderEntier("1. vs IA\n2. vs Humain \nChoix", 1, 2);
        j2 = new Joueur(mode == 1 ? "Ordinateur" : "Joueur 2", mode == 1);

        // Main de départ
        for (int i = 0; i < 6; i++) {
            j1.piocherCarte(tirerCarte());
            j2.piocherCarte(tirerCarte());
        }

        boolean enCours = true;
        Joueur joueurCourant = j1;

        // Boucle de jeu
        while (enCours) {
            vue.afficherPlateau(bornes, j1, j2);

            // Le joueur joue son tour
            jouerTour(joueurCourant);

            // Vérification des bornes conquises
            verifierRevendications();

            // Vérification de la victoire finale
            if (verifierVictoire(joueurCourant)) {
                vue.afficherPlateau(bornes, j1, j2);
                vue.afficherMessage("VICTOIRE DE " + joueurCourant.getNom().toUpperCase() + " !!!");
                enCours = false;
            } 
            // Cas match nul (plus de cartes)
            else if (pioche.isEmpty() && j1.getMain().isEmpty() && j2.getMain().isEmpty()) {
                vue.afficherMessage("Plus de cartes ! Match nul.");
                enCours = false;
            }

            // Changement de joueur
            joueurCourant = (joueurCourant == j1) ? j2 : j1;
        }
    }

    // Piocher une carte et l'enlever du paquet 
    private Carte tirerCarte() {
        return pioche.isEmpty() ? null : pioche.remove(0);
    }

    private void jouerTour(Joueur p) {
        vue.afficherMessage(">>> Tour de " + p.getNom());
        boolean coupValide = false;

        while (!coupValide) {
            int idxCarte = -1;
            int idxBorne = -1;

            if (p.estIA()) {
                // Stratégie IA : on tente jusqu'à trouver un coup légal
                int essais = 0;
                do {
                    int[] action = strategieIA.jouerTour(p, bornes);
                    idxCarte = action[0];
                    idxBorne = action[1];
                    essais++;
                } while (!estCoupValide(p, idxBorne) && essais < 100);

                if (essais >= 100) {
                    vue.afficherMessage("L'IA passe son tour (blocage).");
                    return;
                }
                vue.afficherMessage("L'IA joue sur la borne " + (idxBorne + 1));
            } else {
                // Joueur Humain
                vue.afficherMain(p);
                idxCarte = vue.demanderEntier("Carte à jouer (index)", 0, p.getMain().size() - 1);
                idxBorne = vue.demanderEntier("Sur quelle borne (1-9)", 1, 9) - 1;
            }

            // Exécution du coup
            if (estCoupValide(p, idxBorne)) {
                Carte c = p.jouerCarte(idxCarte);
                // On ajoute la carte sur la borne (true si joueur 1, false si joueur 2)
                bornes.get(idxBorne).ajouterCarte(c, p == j1);

                // Pioche d'une nouvelle carte
                Carte nouvelleCarte = tirerCarte();
                if (nouvelleCarte != null) {
                    p.piocherCarte(nouvelleCarte);
                    if (!p.estIA()) vue.afficherMessage("Vous avez pioché : " + nouvelleCarte);
                }
                coupValide = true;
            } else {
                if (!p.estIA()) vue.afficherMessage("Coup invalide (Borne pleine ou conquise). Réessayez.");
            }
        }
    }

    private boolean estCoupValide(Joueur p, int idxBorne) {
        if (idxBorne < 0 || idxBorne >= 9) return false;
        Borne b = bornes.get(idxBorne);
        // On ne peut pas jouer sur une borne qui a déjà un propriétaire
        if (b.getProprietaire() != null) return false;
        // On vérifie s'il y a de la place du côté du joueur
        return b.ajouterCarte(null, p == j1); 

    }  
    
    private boolean verifierPlace(Joueur p, Borne b) {
        List<Carte> cote = (p == j1) ? b.getCoteJoueur1() : b.getCoteJoueur2();
        return cote.size() < 3;
    }

    private void verifierRevendications() {
        for (Borne b : bornes) {
            // Si la borne n'appartient à personne et qu'elle est complète des deux côtés
            if (b.getProprietaire() == null && b.estPleine()) {
                int score1 = calculerScore(b.getCoteJoueur1());
                int score2 = calculerScore(b.getCoteJoueur2());

                if (score1 > score2) {
                    b.setProprietaire(j1);
                    vue.afficherMessage("Borne " + (b.getId() + 1) + " gagnée par " + j1.getNom());
                } else if (score2 > score1) {
                    b.setProprietaire(j2);
                    vue.afficherMessage("Borne " + (b.getId() + 1) + " gagnée par " + j2.getNom());
                } else {
                    // Égalité 
                    vue.afficherMessage("Egalité sur la borne " + (b.getId() + 1) + " (Pas de vainqueur pour l'instant)");
                }
            }
        }
    }

    /**
     * Calcule la force d'une combinaison de 3 cartes.
     * Système de points :
     * Suite-Couleur = 5000 + somme
     * Brelan = 4000 + somme
     * Couleur = 3000 + somme
     * Suite = 2000 + somme
     * Somme = 1000 + somme
     */
    private int calculerScore(List<Carte> main) {
        List<Carte> triee = new ArrayList<>(main);
        Collections.sort(triee); 

        boolean memeCouleur = (triee.get(0).getCouleur() == triee.get(1).getCouleur() && triee.get(1).getCouleur() == triee.get(2).getCouleur());
        boolean suite = (triee.get(0).getValeur() + 1 == triee.get(1).getValeur() && triee.get(1).getValeur() + 1 == triee.get(2).getValeur());
        boolean memeValeur = (triee.get(0).getValeur() == triee.get(1).getValeur() && triee.get(1).getValeur() == triee.get(2).getValeur());
        
        int somme = triee.stream().mapToInt(Carte::getValeur).sum();

        if (memeCouleur && suite) return 5000 + somme;
        if (memeValeur) return 4000 + somme;
        if (memeCouleur) return 3000 + somme;
        if (suite) return 2000 + somme;
        return 1000 + somme;
    }

    private boolean verifierVictoire(Joueur p) {
        // Victoire par 5 bornes au total
        long bornesPossedees = bornes.stream().filter(b -> b.getProprietaire() == p).count();
        if (bornesPossedees >= 5) return true;

        // Victoire par 3 bornes adjacentes
        for (int i = 0; i < 7; i++) { 
            if (bornes.get(i).getProprietaire() == p &&
                bornes.get(i + 1).getProprietaire() == p &&
                bornes.get(i + 2).getProprietaire() == p) {
                return true;
            }
        }
        return false;
    }
}